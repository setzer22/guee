// NOTE: This whole file is mostly an adaptation from egui::Id
// https://docs.rs/egui/0.20.1/src/egui/id.rs.html

/// guee tracks the state of widgets from frame-to-frame using [`WidgetId`]s.
///
/// For instance, if you start dragging a slider one frame, guee stores the
/// sliders [`WidgetId`] as the current active id so that next frame when you
/// move the mouse the same slider changes, even if the mouse has moved outside
/// the slider.
///
/// This implies that the [`WidgetId`]s must be unique.
#[derive(Clone, Copy, Hash, Eq, PartialEq)]
pub struct WidgetId(u64);

impl WidgetId {
    /// Used by widgets that don't really care about ids, because they have no
    /// data to persist across frames.
    pub fn null() -> WidgetId {
        WidgetId(0)
    }

    /// Generate a new [`Id`] by hashing some source (e.g. a string or integer).
    pub fn new(source: impl std::hash::Hash) -> WidgetId {
        use std::hash::{BuildHasher, Hasher};
        let mut hasher = epaint::ahash::RandomState::with_seeds(1, 2, 3, 4).build_hasher();
        source.hash(&mut hasher);
        WidgetId(hasher.finish())
    }

    /// Generate a new [`Id`] by hashing the parent [`Id`] and the given argument.
    pub fn with(self, child: impl std::hash::Hash) -> WidgetId {
        use std::hash::{BuildHasher, Hasher};
        let mut hasher = epaint::ahash::RandomState::with_seeds(1, 2, 3, 4).build_hasher();
        hasher.write_u64(self.0);
        child.hash(&mut hasher);
        WidgetId(hasher.finish())
    }

    /// Short and readable summary
    pub fn short_debug_format(&self) -> String {
        format!("{:04X}", self.0 as u16)
    }

    #[inline(always)]
    pub(crate) fn value(&self) -> u64 {
        self.0
    }
}

impl std::fmt::Debug for WidgetId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:016X}", self.0)
    }
}

/// Convenience
impl From<&'static str> for WidgetId {
    #[inline]
    fn from(string: &'static str) -> Self {
        Self::new(string)
    }
}

impl From<String> for WidgetId {
    #[inline]
    fn from(string: String) -> Self {
        Self::new(string)
    }
}

/// Hints to generate ids for a widget
pub enum IdGen {
    /// An id will be generated by hashing with the parent widget's id.
    Key(u64),
    /// An id will be set literally with the given value.
    Literal(WidgetId),
}

impl IdGen {
    /// The id for this widget will be generated by hashing the given key onto
    /// the parent's id.
    pub fn key(source: impl std::hash::Hash) -> Self {
        Self::Key(WidgetId::new(source).value())
    }

    /// The id for this widget will be set to the hash of the exact given value.
    pub fn literal(source: impl std::hash::Hash) -> Self {
        Self::Literal(WidgetId::new(source))
    }

    /// For literal id generators, returns the literal value. For key id
    /// generators which depend on the parent id, returns the parent id hashed
    /// with the key.
    pub fn resolve(&self, parent_id: WidgetId) -> WidgetId {
        match self {
            IdGen::Key(k) => parent_id.with(k),
            IdGen::Literal(l) => *l,
        }
    }
}
