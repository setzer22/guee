use epaint::ahash::HashMap;
use std::{
    any::{Any, TypeId},
    marker::PhantomData,
};

/// A `PollToken` is returned when creating an internal callback. The same token
/// can then be reused to try fetch the result of the individual callback once
/// it runs.
///
/// The token is a cheaply copyable handle and can be freely shared or stored
/// around, but one should be careful to store them across frames because
/// callback data is removed from previous frames.
// #[derive(Copy, Clone)] <- see below
pub struct PollToken<T> {
    token: usize,
    _phantom: PhantomData<T>,
}

impl<P> PollToken<P> {
    pub fn as_raw(&self) -> RawPollToken {
        RawPollToken { token: self.token }
    }
}

/// Type-erased `PollToken`. Used by the internal implementation.
#[derive(Clone, Copy, Hash, PartialEq, Eq)]
pub struct RawPollToken {
    token: usize,
}

/// An external callback. See [`Callback`]
pub struct ExternalCallback<P> {
    pub input_type: TypeId,
    #[allow(clippy::type_complexity)]
    pub f: Box<dyn FnOnce(&mut dyn Any, P)>,
}

/// A type-erased callback function. Can be internal or external. Most users
/// will want to use external callbacks. Widget authors might want to use
/// internal callbacks to connect child widgets to their parents. See the docs
/// on each individual variant for more details.
pub enum Callback<P> {
    /// An external callback is provided by end-user, and its invocation is
    /// deferred until the end of each frame.
    ///
    /// This kind of callback consists of a function. That function will be
    /// called by guee, providing mutable access to a portion of the app state,
    /// plus the callback's payload, which is generally event data.
    External(ExternalCallback<P>),
    /// An internal callback is not exactly a callback. It is a mechanism used
    /// by widget authors, allowing listening for the events emitted by other
    /// widgets. It works via a polling mechanism: When a widget dispatches an
    /// event, and that event corresponds to an internal callback, the payload
    /// is stored internally so the parent widget who set up the callback can
    /// fetch it back via its corresponding [`PollToken`]
    Internal { token: PollToken<P> },
}

impl<P> Callback<P> {
    /// If self is an internal callback, clones it. Cloning an internal callback
    /// is a very cheap operation, hence the 'copy' naming. External callbacks
    /// store closures and can't be cloned.
    ///
    /// # Panics
    ///
    /// This function panic when given an external callback.
    pub fn copy_internal(&self) -> Callback<P> {
        match self {
            Callback::External(_) => panic!("Called clone_internal with an external callback"),
            Callback::Internal { token } => Callback::Internal { token: *token },
        }
    }
}

/// A dispatched callback is a type-erased external callback (no generic P) plus
/// its type-erased payload and an invoker function that can be used to run the
/// actual callback code.
///
/// Callback dispatches are generated by widgets code, typically during
/// on_event, to enqueue some things to be called later, when the app state can
/// be accessed.
pub struct DispatchedExternalCallback {
    // The type-erased external callback
    callback: Box<dyn Any>,
    // The stored payload to call the callback with
    payload: Box<dyn Any>,
    // The invoker is a function that takes an erased callback, an erased state
    // and an erased payload, downcasts everything and invokes the callback.
    #[allow(clippy::type_complexity)]
    invoker: Box<dyn FnOnce(Box<dyn Any>, &mut dyn Any, Box<dyn Any>)>,
}

impl DispatchedExternalCallback {
    pub fn new<P: 'static>(c: ExternalCallback<P>, payload: P) -> Self {
        let closure = |cb: Box<dyn Any>, input: &mut dyn Any, p: Box<dyn Any>| {
            let cb: ExternalCallback<P> = *cb.downcast().expect("Downcast failed");
            let p: P = *p.downcast().expect("Downcast failed");
            (cb.f)(input, p);
        };
        DispatchedExternalCallback {
            callback: Box::new(c),
            payload: Box::new(payload),
            invoker: Box::new(closure),
        }
    }

    pub fn invoke(self, state: &mut dyn Any) {
        (self.invoker)(self.callback, state, self.payload)
    }
}

#[derive(Default)]
pub struct DispatchedCallbackStorage {
    /// Stores the results of dispatched callbacks, to be invoked later on when
    /// there's mutable access to the state. Cleared at the end of the frame.
    pub external: Vec<DispatchedExternalCallback>,
    /// Maps poll tokens to the corresponding (type-erased) payload data
    /// returned by the function. Cleared at the end of the frame.
    pub internal: HashMap<RawPollToken, Box<dyn Any>>,
    /// The integer id for the next PollToken to be returned. Reset at the end
    /// of the frame.
    pub next_token: usize,
}

impl DispatchedCallbackStorage {
    pub fn dispatch_callback<P: 'static>(&mut self, c: Callback<P>, payload: P) {
        match c {
            Callback::External(ext) => self
                .external
                .push(DispatchedExternalCallback::new(ext, payload)),
            Callback::Internal { token } => {
                self.internal.insert(token.as_raw(), Box::new(payload));
            }
        }
    }

    /// Call at the end of the frame to run any pending external callbacks and
    /// clean up callback storage for the next frame.
    pub fn end_frame(&mut self, state: &mut dyn Any) {
        self.internal.clear();
        for callback in self.external.drain(..) {
            callback.invoke(state);
        }
        self.next_token = 0;
    }

    /// Creates an internal callback, to be dispatched later via
    /// `dispatch_callback`. Returns both the callback object and the
    /// `PollToken` that calling code can use to fetch the result.
    pub fn create_internal_callback<P: 'static>(&mut self) -> (Callback<P>, PollToken<P>) {
        let token = PollToken::<P> {
            token: self.next_token,
            _phantom: Default::default(),
        };
        self.next_token += 1;
        (Callback::Internal { token }, token)
    }

    /// After an internal callback is fired (and before the end of the frame),
    /// call this function to obtain the callback result via its `PollToken`.
    ///
    /// Note that calling this function will remove the polled value from
    /// storage, and subsequent calls will return None.
    pub fn poll_callback_result<P: 'static>(&mut self, tk: PollToken<P>) -> Option<P> {
        self.internal
            .remove(&tk.as_raw())
            .map(|x| *x.downcast::<P>().expect("Failed downcast"))
    }
}

#[cfg(test)]
mod tests {
    use crate::callback_accessor::CallbackAccessor;

    use super::*;

    #[test]
    fn test_accessor_regitry() {
        #[derive(Default)]
        struct State {
            foo: Foo,
            bar: Bar,
        }
        #[derive(Default)]
        struct Foo {
            baz: Baz,
        }
        #[derive(Default)]
        struct Bar {
            x: f32,
        }
        #[derive(Default)]
        struct Baz {
            y: f32,
        }

        let mut state = State::default();
        let state_cba = CallbackAccessor::<State>::root();

        let bar_cba = state_cba.drill_down(|state| &mut state.bar);
        let bar_cb = bar_cba.callback(|bar, _| {
            bar.x = 123.4;
        });

        let foo_cba = state_cba.drill_down(|state| &mut state.foo);
        let baz_cba = foo_cba.drill_down(|foo| &mut foo.baz);
        let baz_cb = baz_cba.callback(|baz, _| {
            baz.y = 432.1;
        });

        let mut storage = DispatchedCallbackStorage::default();

        storage.dispatch_callback(bar_cb, ());
        storage.dispatch_callback(baz_cb, ());
        storage.end_frame(&mut state);

        assert_eq!(state.bar.x, 123.4);
        assert_eq!(state.foo.baz.y, 432.1);
    }

    #[test]
    fn test_internal_callbacks() {
        let mut storage = DispatchedCallbackStorage::default();
        let (cb, tk) = storage.create_internal_callback();
        assert_eq!(storage.poll_callback_result(tk), None);
        storage.dispatch_callback(cb, "TestString".to_string());
        assert_eq!(storage.poll_callback_result(tk).unwrap(), "TestString");
    }
}

// Boilerplate: Rust doesn't allow derives with PhantomData

impl<P> Clone for PollToken<P> {
    fn clone(&self) -> Self {
        Self {
            token: self.token,
            _phantom: self._phantom,
        }
    }
}

impl<P> Copy for PollToken<P> {}
